package cmd

import (
	"bufio"
	"context"
	"fmt"
	"io"
	"log"
	"octochan/core"
	"os"
	"os/exec"
	"path/filepath"
	"strconv"
	"strings"
	"time"

	"github.com/fsnotify/fsnotify"
	"github.com/hashicorp/go-hclog"
	"github.com/hashicorp/go-plugin"
	"github.com/spf13/cobra"
	"github.com/spf13/viper"
	"gopkg.in/natefinch/lumberjack.v2"
)

var (
	cfgFile  string
	fastMode bool
	watcher  *fsnotify.Watcher
)

var diffCmd = &cobra.Command{
	Use:   "diff <file1> <file2>",
	Short: "–°—Ä–∞–≤–Ω–∏—Ç—å –¥–≤–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–æ–Ω–Ω—ã—Ö —Ñ–∞–π–ª–∞",
	Args:  cobra.RangeArgs(1, 2), // –¢–µ–ø–µ—Ä—å 1-2 –∞—Ä–≥—É–º–µ–Ω—Ç–∞ –≤–º–µ—Å—Ç–æ —Å—Ç—Ä–æ–≥–æ 2
	Run: func(cmd *cobra.Command, args []string) {
		scriptDir, err := core.GetScriptDir()
		if err != nil {
			fmt.Printf("–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ —Å–∫—Ä–∏–ø—Ç–∞: %v\n", err)
			return
		}
		reportsDir := filepath.Join(scriptDir, "reports")
		snapshotsDir := filepath.Join(scriptDir, "snapshots")

		for _, dir := range []string{reportsDir, snapshotsDir} {
			if err := os.MkdirAll(dir, 0755); err != nil {
				fmt.Printf("–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ %s: %v\n", dir, err)
				return
			}
		}

		var content1, content2 string
		var file1, file2 string
		if len(args) > 0 {
			if args[0] == "-" {
				stdinData, err := io.ReadAll(os.Stdin)
				if err != nil {
					fmt.Printf("‚ùå –û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è stdin: %v\n", err)
					return
				}
				content1 = string(stdinData)
				file1 = "stdin"
			} else {
				file1 = resolveInputPath(args[0], scriptDir, reportsDir)
				if !core.FileExists(file1) {
					fmt.Printf("‚ùå –§–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω: %s\n", args[0])
					return
				}
				content, err := core.ReadFile(file1)
				if err != nil {
					fmt.Printf("‚ùå –û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è —Ñ–∞–π–ª–∞: %v\n", err)
					return
				}
				content1 = string(content)
			}
		}

		if len(args) > 1 {
			if args[1] == "-" {
				if file1 == "stdin" {
					fmt.Println("‚ùå –ù–µ–ª—å–∑—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å stdin –¥–ª—è –æ–±–æ–∏—Ö —Ñ–∞–π–ª–æ–≤")
					return
				}
				stdinData, err := io.ReadAll(os.Stdin)
				if err != nil {
					fmt.Printf("‚ùå –û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è stdin: %v\n", err)
					return
				}
				content2 = string(stdinData)
				file2 = "stdin"
			} else {
				file2 = resolveInputPath(args[1], scriptDir, reportsDir)
				if !core.FileExists(file2) {
					fmt.Printf("‚ùå –§–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω: %s\n", args[1])
					return
				}
				content, err := core.ReadFile(file2)
				if err != nil {
					fmt.Printf("‚ùå –û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è —Ñ–∞–π–ª–∞: %v\n", err)
					return
				}
				content2 = string(content)
			}
		} else {
			content2 = ""
			file2 = "empty"
		}

		cfg1, err := core.ParseConfig(content1)
		if err != nil {
			fmt.Printf("‚ùå –û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ –ø–µ—Ä–≤–æ–≥–æ –∫–æ–Ω—Ñ–∏–≥–∞: %v\n", err)
			return
		}

		cfg2, err := core.ParseConfig(content2)
		if err != nil {
			fmt.Printf("‚ùå –û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ –≤—Ç–æ—Ä–æ–≥–æ –∫–æ–Ω—Ñ–∏–≥–∞: %v\n", err)
			return
		}

		diff := core.CompareConfigs(cfg1, cfg2, file1, file2)

		if len(diff) == 0 {
			fmt.Println("–§–∞–π–ª—ã –∏–¥–µ–Ω—Ç–∏—á–Ω—ã!")
			return
		}

		if fastMode {
			fmt.Println("–ù–∞–π–¥–µ–Ω—ã —Ä–∞–∑–ª–∏—á–∏—è (fast mode):")
			for param, vals := range diff {
				fmt.Printf("%s: %s -> %s\n", param, vals[file1], vals[file2])
			}
			return
		}

		fmt.Println("–ù–∞–π–¥–µ–Ω—ã —Ä–∞–∑–ª–∏—á–∏—è:")
		for param, vals := range diff {
			fmt.Printf("%s:\n  %s -> %s\n", param, vals[file1], vals[file2])
		}
		if !IsPipeMode() {
			reportNum, _ := core.GetNextReportNumber(reportsDir)
			outputFile := filepath.Join(reportsDir, fmt.Sprintf("diff_report_%d.txt", reportNum))
			core.SaveDiffToFile(diff, outputFile, file1, file2)
			fmt.Printf("\n–û—Ç—á–µ—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω –≤: %s\n", outputFile)

			snapshot, err := core.CreateSnapshot(nil, cfg1, cfg2, "system", "autogenerated")
			if err != nil {
				fmt.Printf("–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è —Å–Ω–∞–ø—à–æ—Ç–∞: %v\n", err)
				return
			}
			if err := core.SaveSnapshot(snapshot, snapshotsDir); err != nil {
				fmt.Printf("–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Å–Ω–∞–ø—à–æ—Ç–∞: %v\n", err)
				return
			}
			fmt.Printf("–°–Ω–∞–ø—à–æ—Ç —Å–æ–∑–¥–∞–Ω: %s\n", snapshot.ID)
		}
	},
}

var inspectCmd = &cobra.Command{
	Use:   "inspect <module_path>",
	Short: "–ü—Ä–æ–≤–µ—Ä–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –º–æ–¥—É–ª–µ",
	Args:  cobra.ExactArgs(1),
	Run: func(cmd *cobra.Command, args []string) {
		if err := inspectModule(args[0]); err != nil {
			fmt.Printf("‚ùå –û—à–∏–±–∫–∞: %v\n", err)
		}
	},
}
var saveScenarioCmd = &cobra.Command{
	Use:   "srs <scenario.yaml>",
	Short: "–°–æ—Ö—Ä–∞–Ω–∏—Ç—å —Å—Ü–µ–Ω–∞—Ä–∏–π –≤ –±–∏–Ω–∞—Ä–Ω–∏–∫",
	Args:  cobra.ExactArgs(1),
	Run: func(cmd *cobra.Command, args []string) {
		scenarioPath := args[0]
		data, err := os.ReadFile(scenarioPath)
		if err != nil {
			fmt.Printf("‚ùå –û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è —Ñ–∞–π–ª–∞: %v\n", err)
			return
		}

		fm, err := core.NewFileManager()
		if err != nil {
			fmt.Printf("‚ùå –û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ —Ñ–∞–π–ª–æ–≤–æ–≥–æ –º–µ–Ω–µ–¥–∂–µ—Ä–∞: %v\n", err)
			return
		}

		scenarioName := strings.TrimSuffix(filepath.Base(scenarioPath), ".yaml")
		if err := fm.SaveScenario(scenarioName, data); err != nil {
			fmt.Printf("‚ùå –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è: %v\n", err)
			return
		}

		savePath := filepath.Join(fm.BaseDir(), scenarioName+".bin")
		fmt.Printf("‚úÖ –°—Ü–µ–Ω–∞—Ä–∏–π —Å–æ—Ö—Ä–∞–Ω—ë–Ω: %s\n", savePath)
	},
}

var listModulesCmd = &cobra.Command{
	Use:   "modules",
	Short: "–ü–æ–∫–∞–∑–∞—Ç—å —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω—ã–µ –º–æ–¥—É–ª–∏",
	Run: func(cmd *cobra.Command, args []string) {
		fm, _ := core.NewFileManager()
		files, _ := os.ReadDir(fm.ModulesDir())
		for _, f := range files {
			fmt.Println(f.Name())
		}
	},
}

var logsCmd = &cobra.Command{
	Use:   "logs [--tail N]",
	Short: "–ü–æ–∫–∞–∑–∞—Ç—å –ª–æ–≥–∏",
	Run: func(cmd *cobra.Command, args []string) {
		tail, _ := cmd.Flags().GetInt("tail")
		showLogs(tail)
	},
}

var findCmd = &cobra.Command{
	Use:   "find <file> <parameter>",
	Short: "–ù–∞–π—Ç–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä –≤ –∫–æ–Ω—Ñ–∏–≥–µ",
	Run: func(cmd *cobra.Command, args []string) {
		content, _ := os.ReadFile(args[0])
		cfg, _ := core.ParseConfig(string(content))

		for section, params := range cfg {
			if val, ok := params[args[1]]; ok {
				fmt.Printf("[%s] %s = %v\n", section, args[1], val)
			}
		}
	},
}

var installCmd = &cobra.Command{
	Use:   "!install <module_file>",
	Short: "–£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –Ω–æ–≤—ã–π –º–æ–¥—É–ª—å –∫–æ–º–∞–Ω–¥",
	Args:  cobra.ExactArgs(1),
	Run: func(cmd *cobra.Command, args []string) {
		filePath := args[0]

		if !strings.HasSuffix(filePath, ".hcplugin") {
			cmd.PrintErrln("‚ùå –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç—Å—è —Ç–æ–ª—å–∫–æ .hcplugin –º–æ–¥—É–ª–∏")
			return
		}

		data, err := os.ReadFile(filePath)
		if err != nil {
			cmd.PrintErrf("‚ùå –û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è —Ñ–∞–π–ª–∞ –º–æ–¥—É–ª—è: %v\n", err)
			return
		}

		fm, err := core.NewFileManager()
		if err != nil {
			cmd.PrintErrf("‚ùå –û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ —Ñ–∞–π–ª–æ–≤–æ–≥–æ –º–µ–Ω–µ–¥–∂–µ—Ä–∞: %v\n", err)
			return
		}

		moduleName := filepath.Base(filePath)

		if err := fm.InstallHashicorpModule(moduleName, data); err != nil {
			cmd.PrintErrf("‚ùå –û—à–∏–±–∫–∞ —É—Å—Ç–∞–Ω–æ–≤–∫–∏ –º–æ–¥—É–ª—è: %v\n", err)
			return
		}

		modulePath := filepath.Join(fm.ModulesDir(), moduleName)
		if err := core.GetModuleManager().LoadHashicorpPlugin(modulePath); err != nil {
			cmd.PrintErrf("‚ö†Ô∏è –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –ø–ª–∞–≥–∏–Ω–∞: %v\n", err)

			if removeErr := os.Remove(modulePath); removeErr != nil {
				cmd.PrintErrf("‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å –Ω–µ—Ä–∞–±–æ—á–∏–π –º–æ–¥—É–ª—å: %v\n", removeErr)
			}
			return
		}

		cmd.Printf("‚úÖ –ú–æ–¥—É–ª—å [%s] —É—Å–ø–µ—à–Ω–æ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –∏ –∑–∞–≥—Ä—É–∂–µ–Ω\n", moduleName)
	},
}

var helpCmd = &cobra.Command{
	Use:   "help",
	Short: "–û—Ç–æ–±—Ä–∞–∑–∏—Ç—å —Å–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –∫–æ–º–∞–Ω–¥",
	Run: func(cmd *cobra.Command, args []string) {
		fmt.Println("–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:")
		fmt.Println("------------------")

		for _, subCmd := range rootCmd.Commands() {
			fmt.Printf("%-10s - %s\n", subCmd.Use, subCmd.Short)

			if subCmd.Example != "" {
				fmt.Printf("  –ü—Ä–∏–º–µ—Ä: %s\n", subCmd.Example)
			}
		}
	},
}

var patchCmd = &cobra.Command{
	Use:   "patch <base_file> <changes_file>",
	Short: "–ü—Ä–∏–º–µ–Ω–∏—Ç—å –∏–∑–º–µ–Ω–µ–Ω–∏—è –∫ –æ—Å–Ω–æ–≤–Ω–æ–º—É –∫–æ–Ω—Ñ–∏–≥—É",
	Run: func(cmd *cobra.Command, args []string) {
		content1, err := core.ReadFile(args[0])
		if err != nil {
			fmt.Printf("–û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è —Ñ–∞–π–ª–∞: %v\n", err)
			return
		}

		content2, err := core.ReadFile(args[1])
		if err != nil {
			fmt.Printf("–û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è —Ñ–∞–π–ª–∞: %v\n", err)
			return
		}

		base, err := core.ParseConfig(content1)
		if err != nil {
			fmt.Printf("–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞: %v\n", err)
			return
		}

		changes, err := core.ParseConfig(content2)
		if err != nil {
			fmt.Printf("–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞: %v\n", err)
			return
		}

		for section, params := range changes {
			if _, exists := base[section]; !exists {
				base[section] = make(map[string]string)
			}
			for k, v := range params {
				base[section][k] = v
			}
		}

		if err := core.SaveConfig(base, "patched.conf"); err != nil {
			fmt.Printf("–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è: %v\n", err)
			return
		}
		fmt.Println("–ò–∑–º–µ–Ω–µ–Ω–∏—è —É—Å–ø–µ—à–Ω–æ –ø—Ä–∏–º–µ–Ω–µ–Ω—ã –∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã –≤ patched.conf")
	},
}

var authCmd = &cobra.Command{
	Use:   "auth [token]",
	Short: "–£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Ç–æ–∫–µ–Ω –¥–ª—è –¥–æ—Å—Ç—É–ø–∞ –∫ RLM API",
	Args:  cobra.MaximumNArgs(2), // –ò–∑–º–µ–Ω–∏–ª–∏ –Ω–∞ 2
	Run: func(cmd *cobra.Command, args []string) {
		initConfig()

		var token string
		if len(args) == 0 {
			fmt.Print("–í–≤–µ–¥–∏—Ç–µ —Ç–æ–∫–µ–Ω: ")
			scanner := bufio.NewScanner(os.Stdin)
			scanner.Scan()
			token = strings.TrimSpace(scanner.Text())
		} else if len(args) == 2 && strings.EqualFold(args[0], "token") {
			token = strings.TrimSpace(args[1])
		} else {
			token = strings.TrimSpace(args[0])
		}

		home, err := os.UserHomeDir()
		if err != nil {
			fmt.Printf("‚ùå –û—à–∏–±–∫–∞ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –¥–æ–º–∞—à–Ω–µ–π –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏: %v\n", err)
			return
		}

		envPath := filepath.Join(home, ".octochan", ".env")
		envContent := fmt.Sprintf("API_TOKEN=%s\n", token)

		if err := os.WriteFile(envPath, []byte(envContent), 0600); err != nil {
			fmt.Printf("‚ùå –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Ç–æ–∫–µ–Ω–∞: %v\n", err)
			return
		}

		if viper.GetBool("defaults.token_timer_enabled") {
			go startTokenTimer()
		}

		fmt.Println("‚úÖ –¢–æ–∫–µ–Ω —É—Å–ø–µ—à–Ω–æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω")
	},
}
var statusCmd = &cobra.Command{
	Use:   "status <task_id>",
	Short: "–ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Å—Ç–∞—Ç—É—Å –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –∑–∞–¥–∞—á–∏",
	Args:  cobra.ExactArgs(1),
	Run: func(cmd *cobra.Command, args []string) {
		taskID := args[0]
		if err := core.PrintTaskStatus(taskID); err != nil {
			fmt.Printf("‚ùå –û—à–∏–±–∫–∞: %v\n", err)
			return
		}
	},
}

func loadEnv() {
	home, err := os.UserHomeDir()
	if err != nil {
		return
	}

	envPath := filepath.Join(home, ".octochan", ".env")
	if _, err := os.Stat(envPath); os.IsNotExist(err) {
		return
	}

	envFile, err := os.ReadFile(envPath)
	if err != nil {
		return
	}

	lines := strings.Split(string(envFile), "\n")
	for _, line := range lines {
		if strings.HasPrefix(line, "API_TOKEN=") {
			token := strings.TrimPrefix(line, "API_TOKEN=")
			viper.Set("defaults.api_token", token)
		}
	}
}

var timerCmd = &cobra.Command{
	Use:   "timer [on|off]",
	Short: "–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Ç–∞–π–º–µ—Ä–æ–º —Å–º–µ–Ω—ã —Ç–æ–∫–µ–Ω–∞",
	Args:  cobra.MaximumNArgs(1),
	Run: func(cmd *cobra.Command, args []string) {
		if len(args) == 0 {
			status := "–≤—ã–∫–ª—é—á–µ–Ω"
			if viper.GetBool("defaults.token_timer_enabled") {
				status = "–≤–∫–ª—é—á–µ–Ω"
			}
			fmt.Printf("–¢–∞–π–º–µ—Ä —Å–º–µ–Ω—ã —Ç–æ–∫–µ–Ω–∞: %s\n", status)
			return
		}

		switch args[0] {
		case "on":
			viper.Set("defaults.token_timer_enabled", true)
			fmt.Println("–¢–∞–π–º–µ—Ä —Å–º–µ–Ω—ã —Ç–æ–∫–µ–Ω–∞ –≤–∫–ª—é—á–µ–Ω")
			go startTokenTimer()
		case "off":
			viper.Set("defaults.token_timer_enabled", false)
			fmt.Println("–¢–∞–π–º–µ—Ä —Å–º–µ–Ω—ã —Ç–æ–∫–µ–Ω–∞ –≤—ã–∫–ª—é—á–µ–Ω")
		default:
			fmt.Println("–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ: timer on –∏–ª–∏ timer off")
		}

		if err := viper.WriteConfig(); err != nil {
			fmt.Printf("‚ùå –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –Ω–∞—Å—Ç—Ä–æ–µ–∫: %v\n", err)
		}
	},
}

var tokenTimer *time.Timer

func startTokenTimer() {
	if tokenTimer != nil {
		tokenTimer.Stop()
	}

	tokenTimer = time.AfterFunc(15*time.Minute, func() {
		fmt.Println("\n‚ö†Ô∏è –í–ù–ò–ú–ê–ù–ò–ï: –¢–æ–∫–µ–Ω –±—É–¥–µ—Ç –Ω–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª–µ–Ω —á–µ—Ä–µ–∑ 5 –º–∏–Ω—É—Ç!")
		fmt.Println("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ–±–Ω–æ–≤–∏—Ç–µ —Ç–æ–∫–µ–Ω —Å –ø–æ–º–æ—â—å—é –∫–æ–º–∞–Ω–¥—ã 'auth'")

		time.Sleep(10 * time.Minute)
		fmt.Println("\n –¢–æ–∫–µ–Ω –±–æ–ª—å—à–µ –Ω–µ –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª–µ–Ω!")
		fmt.Println("–î–ª—è –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏—è —Ä–∞–±–æ—Ç—ã –æ–±–Ω–æ–≤–∏—Ç–µ —Ç–æ–∫–µ–Ω —Å –ø–æ–º–æ—â—å—é –∫–æ–º–∞–Ω–¥—ã 'auth'")

		viper.Set("defaults.api_token", "")
	})
}

var statsCmd = &cobra.Command{
	Use:   "stats <file>",
	Short: "–ü–æ–∫–∞–∑–∞—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –∫–æ–Ω—Ñ–∏–≥–∞",
	Run: func(cmd *cobra.Command, args []string) {
		content, err := core.ReadFile(args[0])
		if err != nil {
			fmt.Printf("–û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è —Ñ–∞–π–ª–∞: %v\n", err)
			return
		}

		cfg, err := core.ParseConfig(content)
		if err != nil {
			fmt.Printf("–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞: %v\n", err)
			return
		}

		fmt.Printf("–°–µ–∫—Ü–∏–π: %d\n", len(cfg))
		totalParams := 0
		for _, params := range cfg {
			totalParams += len(params)
		}
		fmt.Printf("–ü–∞—Ä–∞–º–µ—Ç—Ä–æ–≤: %d\n", totalParams)
	},
}

var validateCmd = &cobra.Command{
	Use:   "validate <file>",
	Short: "–ü—Ä–æ–≤–µ—Ä–∏—Ç—å –∫–æ–Ω—Ñ–∏–≥ –Ω–∞ –æ—à–∏–±–∫–∏",
	Run: func(cmd *cobra.Command, args []string) {
		content, _ := os.ReadFile(args[0])
		_, err := core.ParseConfig(string(content))
		if err != nil {
			fmt.Printf("–û—à–∏–±–∫–∞: %v\n", err)
			return
		}
		fmt.Println("–ö–æ–Ω—Ñ–∏–≥ –≤–∞–ª–∏–¥–µ–Ω")
	},
}

func resolveInputPath(inputPath, scriptDir, reportsDir string) string {
	if filepath.IsAbs(inputPath) {
		return inputPath
	}

	if core.FileExists(inputPath) {
		return inputPath
	}

	scriptPath := filepath.Join(scriptDir, inputPath)
	if core.FileExists(scriptPath) {
		return scriptPath
	}

	reportsPath := filepath.Join(reportsDir, inputPath)
	if core.FileExists(reportsPath) {
		return reportsPath
	}

	return inputPath
}

func initConfig() {
	home, err := os.UserHomeDir()
	if err != nil {
		fmt.Printf("‚ùå –û—à–∏–±–∫–∞ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –¥–æ–º–∞—à–Ω–µ–π –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏: %v\n", err)
		return
	}

	dirs := []string{
		filepath.Join(home, ".octochan"),
		filepath.Join(home, ".octochan", "scenarios"),
		filepath.Join(home, ".octochan", "reports"),
		filepath.Join(home, ".octochan", "snapshots"),
		filepath.Join(home, ".octochan", "logs"),
		filepath.Join(home, "octochan"),
	}

	for _, dir := range dirs {
		if err := os.MkdirAll(dir, 0755); err != nil {
			fmt.Printf("‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ %s: %v\n", dir, err)
			return
		}
	}

	cfgPath := filepath.Join(home, "octochan", "config.yaml")
	viper.SetConfigFile(cfgPath)

	loadEnv()

	if _, err := os.Stat(cfgPath); os.IsNotExist(err) {
		viper.Set("defaults.api_url", "https://rlm.sigma.sbrf.ru/api/tasks.json")
		viper.Set("defaults.scenario_path", filepath.Join(home, ".octochan", "scenarios"))
		viper.Set("defaults.auto_check_status", false)
		viper.Set("defaults.max_parallel_tasks", 5)
		viper.Set("defaults.log_path", filepath.Join(home, ".octochan", "logs"))
		viper.Set("defaults.log_max_size", 10)
		viper.Set("defaults.log_max_backups", 5)
		viper.Set("defaults.token_timer_enabled", true)
		if err := viper.WriteConfig(); err != nil {
			fmt.Printf("‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –∫–æ–Ω—Ñ–∏–≥–∞: %v\n", err)
		}
	}

	if err := viper.ReadInConfig(); err == nil {
		fmt.Println("‚öôÔ∏è –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –∫–æ–Ω—Ñ–∏–≥:", viper.ConfigFileUsed())
	}

	if viper.GetBool("defaults.token_timer_enabled") && viper.GetString("defaults.api_token") != "" {
		go startTokenTimer()
	}
}
func showLogs(tail int) {
	logPath := viper.GetString("defaults.log_path")
	if logPath == "" {
		home, _ := os.UserHomeDir()
		logPath = filepath.Join(home, ".octochan", "logs")
	}

	logFile := filepath.Join(logPath, "octochan.log")

	if _, err := os.Stat(logFile); os.IsNotExist(err) {
		fmt.Println("‚ÑπÔ∏è –õ–æ–≥-—Ñ–∞–π–ª –µ—â—ë –Ω–µ —Å–æ–∑–¥–∞–Ω, –ø–æ–∫–∞ –Ω–µ—Ç –∑–∞–ø–∏—Å–µ–π")
		return
	}

	content, err := os.ReadFile(logFile)
	if err != nil {
		fmt.Printf("‚ùå –û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è –ª–æ–≥–æ–≤: %v\n", err)
		return
	}

	lines := strings.Split(string(content), "\n")

	if tail <= 0 || tail >= len(lines) {
		fmt.Println(string(content))
		return
	}

	start := len(lines) - tail
	if start < 0 {
		start = 0
	}

	fmt.Println("–ü–æ—Å–ª–µ–¥–Ω–∏–µ", tail, "—Å—Ç—Ä–æ–∫ –ª–æ–≥–æ–≤:")
	for _, line := range lines[start:] {
		fmt.Println(line)
	}
}

func initLogger() {
	logPath := viper.GetString("defaults.log_path")
	if logPath == "" {
		home, _ := os.UserHomeDir()
		logPath = filepath.Join(home, ".octochan", "logs")
	}

	if err := os.MkdirAll(logPath, 0755); err != nil {
		fmt.Printf("‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ –ª–æ–≥–æ–≤: %v\n", err)
		os.Exit(1)
	}

	logFile := filepath.Join(logPath, "rlm-cli.log")
	writer := &lumberjack.Logger{
		Filename:   logFile,
		MaxSize:    viper.GetInt("defaults.log_max_size"),
		MaxBackups: viper.GetInt("defaults.log_max_backups"),
		Compress:   true,
	}

	log.SetOutput(io.MultiWriter(os.Stdout, writer))
	log.SetFlags(log.LstdFlags | log.Lshortfile)
}

func watchModules() {
	fm, err := core.NewFileManager()
	if err != nil {
		log.Printf("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å FileManager: %v", err)
		return
	}

	watcher, err := fsnotify.NewWatcher()
	if err != nil {
		log.Printf("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å watcher: %v", err)
		return
	}
	defer watcher.Close()

	err = watcher.Add(fm.ModulesDir())
	if err != nil {
		log.Printf("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –¥–æ–±–∞–≤–∏—Ç—å –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –¥–ª—è –Ω–∞–±–ª—é–¥–µ–Ω–∏—è: %v", err)
		return
	}

	log.Println("–ù–∞–±–ª—é–¥–µ–Ω–∏–µ –∑–∞ –∏–∑–º–µ–Ω–µ–Ω–∏—è–º–∏ –º–æ–¥—É–ª–µ–π –∑–∞–ø—É—â–µ–Ω–æ")

	for {
		select {
		case event, ok := <-watcher.Events:
			if !ok {
				return
			}

			if event.Op&fsnotify.Write == fsnotify.Write &&
				strings.HasSuffix(event.Name, ".hcplugin") {
				log.Printf("–û–±–Ω–∞—Ä—É–∂–µ–Ω–æ –∏–∑–º–µ–Ω–µ–Ω–∏–µ –º–æ–¥—É–ª—è: %s", event.Name)
				if err := core.GetModuleManager().LoadHashicorpPlugin(event.Name); err != nil {
					log.Printf("‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç—å –º–æ–¥—É–ª—å %s: %v", event.Name, err)
				} else {
					log.Printf("‚úÖ –ú–æ–¥—É–ª—å %s —É—Å–ø–µ—à–Ω–æ –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∂–µ–Ω", event.Name)
					RefreshCommands()
				}
			}

		case err, ok := <-watcher.Errors:
			if !ok {
				return
			}
			log.Printf("–û—à–∏–±–∫–∞ watcher: %v", err)
		}
	}
}

var lastIfResult *bool
var ifCmd = &cobra.Command{
	Use:   "if [—Ñ–∞–π–ª] [—Å–µ–∫—Ü–∏—è.–ø–∞—Ä–∞–º–µ—Ç—Ä] [–æ–ø–µ—Ä–∞—Ç–æ—Ä] [–∑–Ω–∞—á–µ–Ω–∏–µ] [—Ä–µ–∑—É–ª—å—Ç–∞—Ç]",
	Short: "–£—Å–ª–æ–≤–Ω—ã–π –æ–ø–µ—Ä–∞—Ç–æ—Ä –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –∑–Ω–∞—á–µ–Ω–∏–π –≤ –∫–æ–Ω—Ñ–∏–≥–µ",
	Example: `if config.conf server.port == 8080 "–ü–æ—Ä—Ç –∫–æ—Ä—Ä–µ–∫—Ç–µ–Ω"
if config.conf database.enabled != false "–í–∫–ª—é—á–∏—Ç–µ –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö"`,
	Args: cobra.ExactArgs(5),
	Run: func(cmd *cobra.Command, args []string) {
		filePath := args[0]
		paramPath := args[1]
		operator := args[2]
		expectedValue := args[3]
		resultMessage := args[4]

		content, err := os.ReadFile(filePath)
		if err != nil {
			fmt.Printf("‚ùå –û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è —Ñ–∞–π–ª–∞: %v\n", err)
			return
		}

		cfg, err := core.ParseConfig(string(content))
		if err != nil {
			fmt.Printf("‚ùå –û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ –∫–æ–Ω—Ñ–∏–≥–∞: %v\n", err)
			return
		}

		parts := strings.Split(paramPath, ".")
		if len(parts) != 2 {
			fmt.Printf("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –ø–∞—Ä–∞–º–µ—Ç—Ä–∞. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ: section.param\n")
			return
		}

		section, param := parts[0], parts[1]

		currentValue, exists := cfg[section][param]
		if !exists {
			fmt.Printf("‚ùå –ü–∞—Ä–∞–º–µ—Ç—Ä %s –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ —Å–µ–∫—Ü–∏–∏ %s\n", param, section)
			return
		}

		isConditionMet := false

		switch operator {
		case "==":
			isConditionMet = (currentValue == expectedValue)
		case "!=":
			isConditionMet = (currentValue != expectedValue)
		case ">":

			currentNum, err1 := strconv.Atoi(currentValue)
			expectedNum, err2 := strconv.Atoi(expectedValue)
			if err1 == nil && err2 == nil {
				isConditionMet = (currentNum > expectedNum)
			} else {
				isConditionMet = (currentValue > expectedValue)
			}
		case "<":
			currentNum, err1 := strconv.Atoi(currentValue)
			expectedNum, err2 := strconv.Atoi(expectedValue)
			if err1 == nil && err2 == nil {
				isConditionMet = (currentNum < expectedNum)
			} else {
				isConditionMet = (currentValue < expectedValue)
			}
		case ">=":
			currentNum, err1 := strconv.Atoi(currentValue)
			expectedNum, err2 := strconv.Atoi(expectedValue)
			if err1 == nil && err2 == nil {
				isConditionMet = (currentNum >= expectedNum)
			} else {
				isConditionMet = (currentValue >= expectedValue)
			}
		case "<=":
			currentNum, err1 := strconv.Atoi(currentValue)
			expectedNum, err2 := strconv.Atoi(expectedValue)
			if err1 == nil && err2 == nil {
				isConditionMet = (currentNum <= expectedNum)
			} else {
				isConditionMet = (currentValue <= expectedValue)
			}
		case "contains":
			isConditionMet = strings.Contains(currentValue, expectedValue)
		case "startsWith":
			isConditionMet = strings.HasPrefix(currentValue, expectedValue)
		case "endsWith":
			isConditionMet = strings.HasSuffix(currentValue, expectedValue)
		default:
			fmt.Printf(" –ù–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–π –æ–ø–µ—Ä–∞—Ç–æ—Ä: %s\n", operator)
			fmt.Println("–î–æ—Å—Ç—É–ø–Ω—ã–µ –æ–ø–µ—Ä–∞—Ç–æ—Ä—ã: ==, !=, >, <, >=, <=, contains, startsWith, endsWith")
			return
		}

		lastIfResult = &isConditionMet
		if isConditionMet {
			fmt.Printf(" %s\n", resultMessage)
			fmt.Printf("   %s = %s %s %s\n", paramPath, currentValue, operator, expectedValue)
		} else {
			fmt.Printf(" –£—Å–ª–æ–≤–∏–µ –Ω–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–æ: %s %s %s\n",
				currentValue, operator, expectedValue)
		}
	},
}
var applyCmd = &cobra.Command{
	Use:   "apply [-rlm] [file] [custom_params...]",
	Short: "–ü—Ä–∏–º–µ–Ω–∏—Ç—å —Å—Ü–µ–Ω–∞—Ä–∏–π –∏–ª–∏ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é",
	Args:  cobra.MinimumNArgs(0),
	Run: func(cmd *cobra.Command, args []string) {
		useRLM, _ := cmd.Flags().GetBool("rlm")

		if useRLM {
			log.Println("=== Starting new apply operation ===")
			defer log.Println("=== Apply operation completed ===")

			var scenarioData []byte
			var customParams map[string]string

			if len(args) > 0 && args[0] != "-" {
				data, err := os.ReadFile(args[0])
				if err != nil {
					fmt.Printf("‚ùå –û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è —Ñ–∞–π–ª–∞: %v\n", err)
					return
				}
				scenarioData = data
				if len(args) > 1 {
					customParams = make(map[string]string)
					for _, param := range args[1:] {
						parts := strings.SplitN(param, "=", 2)
						if len(parts) == 2 {
							customParams[parts[0]] = parts[1]
							log.Printf("Added custom param: %s=%s", parts[0], parts[1])
						} else {
							log.Printf("‚ö†Ô∏è Invalid parameter format: %s", param)
						}
					}
				}
			} else {
				stdinData, err := io.ReadAll(os.Stdin)
				if err != nil {
					fmt.Printf("‚ùå –û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è stdin: %v\n", err)
					return
				}
				scenarioData = stdinData

				if len(args) > 0 && args[0] == "-" {
					customParams = make(map[string]string)
					for _, param := range args[1:] {
						parts := strings.SplitN(param, "=", 2)
						if len(parts) == 2 {
							customParams[parts[0]] = parts[1]
							log.Printf("Added custom param: %s=%s", parts[0], parts[1])
						} else {
							log.Printf("‚ö†Ô∏è Invalid parameter format: %s", param)
						}
					}
				} else if len(args) > 0 {
					customParams = make(map[string]string)
					for _, param := range args {
						parts := strings.SplitN(param, "=", 2)
						if len(parts) == 2 {
							customParams[parts[0]] = parts[1]
							log.Printf("Added custom param: %s=%s", parts[0], parts[1])
						} else {
							log.Printf("‚ö†Ô∏è Invalid parameter format: %s", param)
						}
					}
				}
			}

			token := viper.GetString("defaults.api_token")
			if token == "" {
				fmt.Println("‚ùå –¢–æ–∫–µ–Ω –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—É 'auth' –¥–ª—è —É—Å—Ç–∞–Ω–æ–≤–∫–∏ —Ç–æ–∫–µ–Ω–∞")
				return
			}

			taskIDs, err := core.ExecuteScenarioData(scenarioData, customParams)
			if err != nil {
				fmt.Printf("‚ùå –û—à–∏–±–∫–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —Å—Ü–µ–Ω–∞—Ä–∏—è: %v\n", err)
				return
			}

			fmt.Println("‚úÖ –°–æ–∑–¥–∞–Ω–Ω—ã–µ –∑–∞–¥–∞—á–∏:")
			for _, taskID := range taskIDs {
				fmt.Printf("- %s\n", taskID)
			}

			if viper.GetBool("defaults.auto_check_status") {
				fmt.Println("\nüîÑ –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–∞—Ç—É—Å–æ–≤ –∑–∞–¥–∞—á...")
				for _, taskID := range taskIDs {
					status, err := core.GetTaskStatus(taskID)
					if err != nil {
						fmt.Printf("‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ–≤–µ—Ä–∏—Ç—å —Å—Ç–∞—Ç—É—Å –∑–∞–¥–∞—á–∏ %s: %v\n", taskID, err)
					} else {
						fmt.Printf("- %s: %s\n", taskID, status["status"])
					}
				}
			}
		} else {
			fmt.Println("–ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ –æ–±—ã—á–Ω–æ–≥–æ –∫–æ–Ω—Ñ–∏–≥–∞...")

			if len(args) == 0 {
				fmt.Println("‚ùå –î–ª—è –æ–±—ã—á–Ω–æ–≥–æ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è —É–∫–∞–∂–∏—Ç–µ —Ñ–∞–π–ª –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏")
				return
			}

			var configData []byte
			var err error

			if args[0] == "-" {
				configData, err = io.ReadAll(os.Stdin)
				if err != nil {
					fmt.Printf("‚ùå –û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è stdin: %v\n", err)
					return
				}
			} else {
				configData, err = os.ReadFile(args[0])
				if err != nil {
					fmt.Printf("‚ùå –û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è —Ñ–∞–π–ª–∞: %v\n", err)
					return
				}
			}

			fmt.Printf("–ü—Ä–∏–º–µ–Ω—è–µ–º –∫–æ–Ω—Ñ–∏–≥ (%d bytes)...\n", len(configData))
		}
	},
}

func inspectModule(path string) error {
	if !strings.HasSuffix(path, ".hcplugin") {
		return fmt.Errorf("–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç—Å—è —Ç–æ–ª—å–∫–æ .hcplugin –º–æ–¥—É–ª–∏")
	}

	if watcher != nil {
		if err := watcher.Remove(path); err != nil {
			log.Printf("‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫–ª—é—á–∏—Ç—å watcher: %v", err)
		}
		defer func() {
			if err := watcher.Add(path); err != nil {
				log.Printf("‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å watcher: %v", err)
			}
		}()
	}

	if _, err := os.Stat(path); os.IsNotExist(err) {
		return fmt.Errorf("—Ñ–∞–π–ª –º–æ–¥—É–ª—è –Ω–µ –Ω–∞–π–¥–µ–Ω: %s", path)
	}

	logger := hclog.New(&hclog.LoggerOptions{
		Name:   "module-inspector",
		Output: os.Stdout,
		Level:  hclog.Info,
	})

	client := plugin.NewClient(&plugin.ClientConfig{
		HandshakeConfig: plugin.HandshakeConfig{
			ProtocolVersion:  1,
			MagicCookieKey:   "OCTOCHAN_PLUGIN",
			MagicCookieValue: "octochan-2025",
		},
		Plugins: map[string]plugin.Plugin{
			"command": &core.CommandPlugin{},
		},
		Cmd:              exec.Command(path),
		Logger:           logger,
		AllowedProtocols: []plugin.Protocol{plugin.ProtocolGRPC},
		StartTimeout:     5 * time.Second,
		Stderr:           os.Stderr,
	})

	defer func() {
		client.Kill()
		time.Sleep(100 * time.Millisecond)
	}()

	rpcClient, err := client.Client()
	if err != nil {
		return fmt.Errorf("RPC –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ: %w", err)
	}

	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	raw, err := rpcClient.Dispense("command")
	if err != nil {
		return fmt.Errorf("–Ω–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å: %w", err)
	}
	if ctx.Err() == context.DeadlineExceeded {
		return fmt.Errorf("—Ç–∞–π–º–∞—É—Ç –ø—Ä–æ–≤–µ—Ä–∫–∏ –º–æ–¥—É–ª—è")
	}

	module, ok := raw.(core.CommandModule)
	if !ok {
		return fmt.Errorf("–Ω–µ–≤–µ—Ä–Ω—ã–π —Ç–∏–ø –º–æ–¥—É–ª—è")
	}

	fmt.Printf("\n=== –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –º–æ–¥—É–ª–µ ===\n")
	fmt.Printf("–§–∞–π–ª: %s\n", path)
	fmt.Printf("–ò–º—è: %s\n", module.Name())
	fmt.Printf("–í–µ—Ä—Å–∏—è: %s\n", module.Version())

	cmds := module.GetCommands()
	if len(cmds) == 0 {
		fmt.Println("‚ö†Ô∏è –ú–æ–¥—É–ª—å –Ω–µ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ—Ç –∫–æ–º–∞–Ω–¥")
		return nil
	}
	fmt.Println("–ö–æ–º–∞–Ω–¥—ã:")
	for _, cmd := range cmds {
		desc := cmd.Short
		if desc == "" {
			desc = "(–Ω–µ—Ç –æ–ø–∏—Å–∞–Ω–∏—è)"
		}
		fmt.Printf("  %-10s - %s\n", cmd.Use, desc)

		if cmd.Example != "" {
			fmt.Printf("    –ü—Ä–∏–º–µ—Ä: %s\n", cmd.Example)
		}
		if cmd.Annotations != nil {
			fmt.Printf("    –ê–Ω–Ω–æ—Ç–∞—Ü–∏–∏: %v\n", cmd.Annotations)
		}
	}

	return nil
}

func loadModules() {
	mm := core.GetModuleManager()
	if len(mm.GetCommands()) > 0 {
		return
	}

	fm, err := core.NewFileManager()
	if err != nil {
		log.Printf("‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å FileManager: %v", err)
		return
	}

	if err := core.GetModuleManager().LoadModulesFromDir(fm.ModulesDir()); err != nil {
		log.Printf("‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –º–æ–¥—É–ª–µ–π: %v", err)
	}
	if watcher == nil {
		go watchModules()
	}
}

func loadModuleCommands() {
	existingCommands := make(map[string]bool)
	for _, c := range rootCmd.Commands() {
		existingCommands[c.Use] = true
	}

	for _, cmd := range core.GetModuleManager().GetCommands() {
		if !existingCommands[cmd.Use] {
			if cmd.Annotations == nil {
				cmd.Annotations = make(map[string]string)
			}
			cmd.Annotations["source"] = "module"

			rootCmd.AddCommand(cmd)
			log.Printf("Added module command: %s", cmd.Use)
		}
	}
}

func RefreshCommands() {
	var newCommands []*cobra.Command
	for _, cmd := range rootCmd.Commands() {
		if !isModuleCommand(cmd) {
			newCommands = append(newCommands, cmd)
		}
	}
	rootCmd.ResetCommands()
	rootCmd.AddCommand(newCommands...)
	loadModuleCommands()
}

func isModuleCommand(cmd *cobra.Command) bool {
	if cmd.Annotations != nil && cmd.Annotations["source"] == "module" {
		return true
	}
	return false
}

var printCmd = &cobra.Command{
	Use:   "print [file]",
	Short: "Print file or stdin content",
	Args:  cobra.MaximumNArgs(1),
	Run: func(cmd *cobra.Command, args []string) {
		if len(args) > 0 {
			content, err := os.ReadFile(args[0])
			if err != nil {
				fmt.Printf("‚ùå Error reading file: %v\n", err)
				return
			}
			fmt.Print(string(content))
		} else {
			stat, _ := os.Stdin.Stat()
			if (stat.Mode() & os.ModeCharDevice) == 0 {
				content, _ := io.ReadAll(os.Stdin)
				fmt.Print(string(content))
			} else {
				cmd.Help()
				fmt.Println("\n‚ùå –£–∫–∞–∂–∏—Ç–µ —Ñ–∞–π–ª –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ pipe:")
				fmt.Println("  print file.txt")
				fmt.Println("  echo 'hello' | print")
			}
		}
	},
}
var elseCmd = &cobra.Command{
	Use:   "else [—Ñ–∞–π–ª] [—Å–µ–∫—Ü–∏—è.–ø–∞—Ä–∞–º–µ—Ç—Ä] [–æ–ø–µ—Ä–∞—Ç–æ—Ä] [–∑–Ω–∞—á–µ–Ω–∏–µ] [—Ä–µ–∑—É–ª—å—Ç–∞—Ç]",
	Short: "–ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω–æ–µ —É—Å–ª–æ–≤–∏–µ (–≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è –µ—Å–ª–∏ –ø—Ä–µ–¥—ã–¥—É—â–∏–π if –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª)",
	Example: `if config.conf server.port == 8080 "–ü–æ—Ä—Ç –∫–æ—Ä—Ä–µ–∫—Ç–µ–Ω"
else config.conf server.port != 8080 "–ò—Å–ø—Ä–∞–≤—å—Ç–µ –ø–æ—Ä—Ç –Ω–∞ 8080"`,
	Args: cobra.ExactArgs(5),
	Run: func(cmd *cobra.Command, args []string) {

		if lastIfResult == nil {
			fmt.Println("‚ùå –ö–æ–º–∞–Ω–¥–∞ else –¥–æ–ª–∂–Ω–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –ø–æ—Å–ª–µ –∫–æ–º–∞–Ω–¥—ã if")
			return
		}
		if *lastIfResult {
			fmt.Println("‚ÑπÔ∏è –ü—Ä–µ–¥—ã–¥—É—â–µ–µ —É—Å–ª–æ–≤–∏–µ if –≤—ã–ø–æ–ª–Ω–µ–Ω–æ, else –ø—Ä–æ–ø—É—Å–∫–∞–µ—Ç—Å—è")
			return
		}

		filePath := args[0]
		paramPath := args[1]
		operator := args[2]
		expectedValue := args[3]
		resultMessage := args[4]

		content, err := os.ReadFile(filePath)
		if err != nil {
			fmt.Printf("‚ùå –û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è —Ñ–∞–π–ª–∞: %v\n", err)
			return
		}

		cfg, err := core.ParseConfig(string(content))
		if err != nil {
			fmt.Printf("‚ùå –û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ –∫–æ–Ω—Ñ–∏–≥–∞: %v\n", err)
			return
		}

		parts := strings.Split(paramPath, ".")
		if len(parts) != 2 {
			fmt.Printf("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –ø–∞—Ä–∞–º–µ—Ç—Ä–∞. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ: section.param\n")
			return
		}

		section, param := parts[0], parts[1]

		currentValue, exists := cfg[section][param]
		if !exists {
			fmt.Printf("‚ùå –ü–∞—Ä–∞–º–µ—Ç—Ä %s –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ —Å–µ–∫—Ü–∏–∏ %s\n", param, section)
			return
		}

		isConditionMet := false

		switch operator {
		case "==":
			isConditionMet = (currentValue == expectedValue)
		case "!=":
			isConditionMet = (currentValue != expectedValue)
		case ">":
			currentNum, err1 := strconv.Atoi(currentValue)
			expectedNum, err2 := strconv.Atoi(expectedValue)
			if err1 == nil && err2 == nil {
				isConditionMet = (currentNum > expectedNum)
			} else {
				isConditionMet = (currentValue > expectedValue)
			}
		case "<":
			currentNum, err1 := strconv.Atoi(currentValue)
			expectedNum, err2 := strconv.Atoi(expectedValue)
			if err1 == nil && err2 == nil {
				isConditionMet = (currentNum < expectedNum)
			} else {
				isConditionMet = (currentValue < expectedValue)
			}
		case ">=":
			currentNum, err1 := strconv.Atoi(currentValue)
			expectedNum, err2 := strconv.Atoi(expectedValue)
			if err1 == nil && err2 == nil {
				isConditionMet = (currentNum >= expectedNum)
			} else {
				isConditionMet = (currentValue >= expectedValue)
			}
		case "<=":
			currentNum, err1 := strconv.Atoi(currentValue)
			expectedNum, err2 := strconv.Atoi(expectedValue)
			if err1 == nil && err2 == nil {
				isConditionMet = (currentNum <= expectedNum)
			} else {
				isConditionMet = (currentValue <= expectedValue)
			}
		case "contains":
			isConditionMet = strings.Contains(currentValue, expectedValue)
		case "startsWith":
			isConditionMet = strings.HasPrefix(currentValue, expectedValue)
		case "endsWith":
			isConditionMet = strings.HasSuffix(currentValue, expectedValue)
		default:
			fmt.Printf("‚ùå –ù–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–π –æ–ø–µ—Ä–∞—Ç–æ—Ä: %s\n", operator)
			return
		}

		if isConditionMet {
			fmt.Printf("‚úÖ %s\n", resultMessage)
			fmt.Printf("   %s = %s %s %s\n", paramPath, currentValue, operator, expectedValue)
		} else {
			fmt.Printf("‚ùå –£—Å–ª–æ–≤–∏–µ else –Ω–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–æ: %s %s %s\n",
				currentValue, operator, expectedValue)
		}
	},
}

var teeCmd = &cobra.Command{
	Use:   "tee [file]",
	Short: "Read stdin and write to stdout and file",
	Args:  cobra.MaximumNArgs(1),
	Run: func(cmd *cobra.Command, args []string) {
		content, _ := io.ReadAll(os.Stdin)
		fmt.Print(string(content))
		if len(args) > 0 {
			if err := os.WriteFile(args[0], content, 0644); err != nil {
				fmt.Printf("‚ùå Error writing to file: %v\n", err)
			}
		}
	},
}

func init() {
	rootCmd.SilenceErrors = true
	rootCmd.SilenceUsage = true
	cobra.OnInitialize(initConfig, initLogger, loadModules)
	diffCmd.Flags().BoolVarP(&fastMode, "fast", "f", false, "–¢–æ–ª—å–∫–æ –≤—ã–≤–æ–¥ –≤ –∫–æ–Ω—Å–æ–ª—å –±–µ–∑ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Ñ–∞–π–ª–æ–≤")
	rootCmd.AddCommand(PipeWrapper(diffCmd))
	rootCmd.AddCommand(PipeWrapper(validateCmd))
	rootCmd.AddCommand(PipeWrapper(findCmd))
	rootCmd.AddCommand(PipeWrapper(patchCmd))
	rootCmd.AddCommand(PipeWrapper(statsCmd))
	rootCmd.SetHelpCommand(helpCmd)
	rootCmd.AddCommand(helpCmd)
	rootCmd.AddCommand(PipeWrapper(printCmd))
	rootCmd.AddCommand(PipeWrapper(teeCmd))
	rootCmd.PersistentFlags().StringVar(&cfgFile, "config", "", "–ö–æ–Ω—Ñ–∏–≥ (default: ~/.rlm-cli/config.yaml)")
	rootCmd.AddCommand(PipeWrapper(saveScenarioCmd))
	rootCmd.AddCommand(PipeWrapper(ifCmd))
	rootCmd.AddCommand(authCmd)
	rootCmd.AddCommand(statusCmd)
	applyCmd.Flags().BoolP("rlm", "r", false, "–ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å RLM —Å—Ü–µ–Ω–∞—Ä–∏–π")
	rootCmd.AddCommand(PipeWrapper(applyCmd))
	logsCmd.Flags().Int("tail", 0, "–ü–æ–∫–∞–∑–∞—Ç—å –ø–æ—Å–ª–µ–¥–Ω–∏–µ N —Å—Ç—Ä–æ–∫ –ª–æ–≥–æ–≤ (0 - –≤—Å–µ –ª–æ–≥–∏)")
	rootCmd.AddCommand(logsCmd)
	rootCmd.AddCommand(listModulesCmd)
	rootCmd.AddCommand(installCmd)
	rootCmd.AddCommand(timerCmd)
	rootCmd.AddCommand(inspectCmd)

	loadModuleCommands()
}
